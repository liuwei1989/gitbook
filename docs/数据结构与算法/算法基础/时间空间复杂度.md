# 时间空间复杂度

衡量不同算法之间的优劣主要是从算法所占用的「时间」和「空间」两个维度去考量。

> 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。

> 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

## 渐进时间复杂度

若存在函数 f（n），使得当n趋近于无穷大时，T（n）/ f（n）的极限值为不等于零的常数，则称 f（n）是T（n）的同数量级函数。

记作 T（n）= O（f（n）），称O（f（n））为算法的渐进时间复杂度，简称时间复杂度。

渐进时间复杂度用大写O来表示，所以也被称为大O表示法。


### 如何推导出时间复杂度呢？有如下几个原则：

1. 如果运行时间是常数量级，用常数1表示；
2. 只保留时间函数中的最高阶项；
3. 如果最高阶项存在，则省去最高阶项前面的系数。


### 常见的时间复杂度量级

1. 常数阶O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```
    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
```
上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。


2. 对数阶O(logn)

```
int i = 1;
while(i<n){
    i = i * 2;
}
```
从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于n了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)


3. 线性阶O(n)

一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。
```
for(i=1; i<=n; ++i){
   j = i;
   j++;
}

```
这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。



4. 线性对数阶O(nlogn)

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。
```
for(m=1; m<n; m++){
    i = 1;
    while(i<n){
        i = i * 2;
    }
}
```

5. 平方阶O(n²)

平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。举例：

```
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}

```
这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 
如果将其中一层循环的n改成m，即：

```
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}

```
那它的时间复杂度就变成了 O(m*n)


6. 立方阶O(n³)
7. K次方阶O(n^k)
8. 指数阶(2^n)

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

## 空间复杂度

定义：算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

1. 常量空间 空间复杂度 O(1)

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 举例：

```
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```
代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

2. 线性空间 空间复杂度 O(n)


```
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```
这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

3. 二维空间 空间复杂度 O(n<sup>2</sup>)

当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记为O(n2)
```
int[][] m = new int[n][n]
```

4. 递归空间 空间复杂度O(n)

递归是一个比较特殊的场景。虽然递归代码里面没有显示的声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。
```
void fun(int n){
    if(n<=1){
        return;
    }
    fun(n-1)
}
```


[参考文章1](https://blog.csdn.net/qq_41523096/article/details/82142747)
[参考文章2](https://www.jianshu.com/p/88a1c8ed6254)
[参考文章3](https://blog.csdn.net/jsjwk/article/details/84315770)